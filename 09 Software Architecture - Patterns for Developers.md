# Software Architecture: Patterns for Developers

## The Context of Software Architecture Patterns

### What are software architecture patterns?
- [Instructor] It's important to have a shared understanding of the term software architecture patterns, so let's try to come up with a definition. A pattern in software is basically a solution to a common problem. Many developers have encountered similar problems and devised good solutions. If you're facing the same type of problem, you might be able to solve it by applying that solution. Essentially, the pattern defines components and the interactions between them. We can compare it to writing. If you want to bring across a message, you can just start writing away wildly, saying whatever comes to mind, but that wouldn't help in communicating your message effectively. You could do better by structuring your text with an introduction, a body, and a conclusion. Here's another example. A lot of fantasy books follow what's called a three-act structure. First, the characters are introduced, and there is a problem which forces them to go on an adventure. Then there's the actual adventure, where the characters work towards a goal, and finally, there's the big finale in which they are usually victorious. There are many other writing and storytelling patterns, but the point is that they give both the author and the reader a structure that they can follow easily. Similarly, there are many different types of software patterns. What most developers think about when they hear the term are things like the repository, the singleton, the builder, or the factory pattern. These are patterns that define how to write and interact with certain pieces of code, often organized in classes. The repository pattern, for example, shows us how we can abstract away implementation details on how to retrieve data from a database. In a piece of our application, we call a repository containing the logic to build and send a SQL query to the database. It also contains the necessary code to translate the database response to the format that the application code will understand. Here's another example. To parse a string into an integer in C#, you can use the following code: int x = in.Parse("3");. This will return an integer. But what happens if we use a string that doesn't represent a number? Like, if we try to parse the text, hello. This will throw an exception. If we're not sure about the input, we can use the TryParse method, like this, int z = 0; if (int.TryParse (input, out z)). This function will not throw an exception if it can't parse the input. This is called the TryParse pattern. It can be found in several places in .NET. If you're writing a piece of code that needs to parse some input, you can follow this convention by writing a Parse function that throws an exception and a TryParse that doesn't. This makes it recognizable to other developers that will be using your code. So you see how we can encounter patterns at different levels in software. Sometimes it's just a single function. Sometimes it's about a module or a collection of modules, and it can even be about how a collection of applications interacts. In this course, we'll be looking above the single module or class level and see how to give structure to a complete application.

### Why software architecture patterns?
- [Instructor] Why do software architecture patterns exist at all? Can't we just write code and see how it evolves? Isn't that what Agile is all about? Well, using known patterns has significant advantages. We can compare it to the blueprint of a house. You can build a house without it, and you might end up with something fairly okay. But if you want to build something larger and more complex, you'll want a solid plan. This way, what you're building will last longer. Software patterns mean you don't have to spend time inventing solutions when they're already available. Using known patterns will make your code recognizable to other developers who join the project later on. This makes it easier for them to get up to speed, which is beneficial to the entire organization. The patterns are featured in many pieces of literature and documentation. If you have any questions about them, it's easy to find information, help, and reference implementations. Knowing several software architecture patterns means you can apply them to your projects. It allows you to weigh the pros and cons of taking different approaches, and it can help identify improvements you can make to the current architecture of your projects. Finally, these patterns improve the quality and structure of your application, reducing the risk of bugs or unmaintainable software. All these points allow you to become a more productive member of your team, and they make a team as a whole more productive. There are some caveats, however. The problem you're facing may have multiple possible solutions, making it difficult to make a choice. And there's no guarantee that the pattern will be the solution you remain happy with as time goes by. It's just that, for similar problems, certain patterns have proven to be very helpful for thousands of teams and organizations. So, it will be a good starting point for you as well. If a chosen pattern proves to be a bad solution in your case, then you can take a different approach. But in order to make that decision, you need to know about the different patterns. Software architecture patterns will make your applications better, and you as a developer as well.

### The difference with design patterns
- [Instructor] This course covers software architecture patterns. We won't be covering design patterns, so it's useful to look at where we draw the line. Let's define what design patterns are first. Design patterns define a small number of components that can be used in an application. They don't describe how the application itself should be structured. Design patterns only tell us what a specific piece of code must do, and how other pieces of code should interact with it. For example, the factory pattern tells us that we can write a customer factory class with a create method. The factory then has all the complex logic of creating a customer. Any other piece of code that needs to create a customer can just call this customer factory. But this pattern doesn't say anything about how other pieces of the application should be structured. Software architecture patterns occur at a higher level, or looking at many components and their interactions that make up a significant part of the application or even define it. For example, will we structure our application in distinct layers, or should we split it up into multiple independent processes on physically separated servers? And if we do, should they communicate over a central messaging system or directly with each other? Software architecture patterns will give you a holistic view of how you can develop your applications.

### Categories of patterns
- [Instructor] To get a better overview of the different types of software architecture patterns, we'll put them in three distinct categories. These three categories are System Patterns, Application Patterns and User Interface Patterns. System Patterns are software architecture patterns that help us create a single application as it is viewed by the end-user. This end-user can be a human person, but also another application. The system can also consist of multiple running processes behind the scenes, but this is usually hidden from the end-User. We'll start with the monolith, end-tier, service-oriented, microservices and serverless. Then, we'll look at some consequences of the distributed system architectures. And finally, we'll cover the peer-to-peer architecture. Application Patterns are a category of patterns that define how a single executable should be built. So it's about the internal structure of a single executable. This executable can be the only component in the system, or it can be part of a larger system with many components. In this category, we'll look at the layered pattern, the onion architecture, the ports and adapters or hexagonal architecture. We'll then look at the differences between layered onion and ports and adapters because they will look similar. Next, we'll continue with the modular monolith, the microkernel, command query responsibility segregation or CQRS, event sourcing, and finally, the combination of CQRS and event sourcing. The last category of software architecture patterns is all about the user interface. This is where we come close to design patterns, but they're an important part of the application. And sometimes, the UI is the application. So that's why I want to go over them in this course as well. We'll be looking at forms and controls, model view controller, model view presenter, and model view view model. We'll finish with a look at the differences between these patterns. Now that we have everything neatly put into categories, we're ready to start learning the actual patterns.

Q: How do software architecture patterns differ from software design patterns?
A: Architecture patterns define an important application part; design patterns describe a small number of components inside an application.

Q: Why should you use software architecture patterns?
A: They make development more efficient.

Q: What is a software architecture pattern?
A: a high-level solution to a problem that is commonly encountered in architecture development

## System Patterns

### Monolith
- [Instructor] The monolith is a simple architectural pattern, which is why it's so popular and you encounter it often. The monolith is an application that consists of a single executable that contains all the logic to solve the problem at hand. When a new feature is requested, the code is added to the existing source. Even though the monolith has a bad reputation, it does have advantages when applied correctly. First, it's a simple architecture that is easy to understand, implement, and test. Because of its simplicity, it's usually easy to deploy. There isn't a big need for coordination with other systems or teams. This makes it ideal for projects with a limited scope or to get started. But once the application starts to grow, the disadvantages can become apparent. In a monolith, tight coupling is easily introduced by accident. This makes it harder to move all pieces of logic to other applications later. Even though the monolith doesn't mean complex code by definition, it has often led to situations where developers find it hard to modify or extend the application. Another disadvantage of the monolith is that it can lead to a one-size fits-all approach. Some parts of the application might benefit from being developed with other patterns and technologies, but the monolith makes it difficult to do. Let's have a look at a monolithic application. In the exercise files, you can look at the monolith in your editor of choice. I've got it open in Visual Studio. If we run the application, we'll see a dashboard. Now, if we click this URL, we'll see the website of a travel agency. We can list the tours, click on learn More button, and book a tour. When the tour has been booked, we can go back to our dashboard and check out the logs. We should see that there's a line about how we sent an email and how we made a call to an external API. These are just fake implementations. In a real application, we could call an SMTP server to send out a mail and an external API to notify another system of the booking. These are not part of our architecture. Now, if we query our database for the bookings, we'll see that the booking has been stored in the booking table. You can use your tool of choice. I'm using the free SQL Server Management Studio. Let's take a look at the code now. The project is organized into folders. Everything starts with a page. For example, here, we can see the tours page. It contains the UI markup to display the tours. In the code behind file, you'll find the code to load the tours. We're calling the GetTours method on the tours repository class, which contains the SQL code to retrieve the tours from the database. I've put these in the DataAccess folder. There's also a Domain folder, which contains our domain classes Booking and Tour. And finally, there's the Services folder, which contains our codes to call external services. Regardless of how the code is organized internally, this will all be compiled into a single executable. It contains the logic for the UI, the database, external APIs, sending emails, and business logic. The application can consist of multiple files, but they belong together and are deployed as a single unit to a server or workstation. Remember, the monolith may have a bad reputation, but a monolith is not synonymous with badly structured code. It's perfectly possible to build a clean monolith and let it evolve into other architectural patterns when necessary. This is something we'll cover in the chapter on modular monoliths.

### N-tier
- [Narrator] Let's take a look at what an N-tier or multi-tier architecture looks like. An N-tier architecture is an architecture that splits up the application into multiple tiers. A tier is a piece of the application that is responsible for a certain function and that can be physically separated from the other tiers. This makes them different from mere layers in a single executable application. The responsibilities in a multi-tier application are split up across technical boundaries, not functional ones. A typical N-tier setup is the three-tier architecture. A three-tier application consists of three systems, the presentation tier, which contains the UI and any logic that is pure UI logic. Then there's the business tier, which contains all business logic of the application, independent of UI or data storage technology. Finally, the data tier contains the database. These tiers can be installed on the same system, but they can also be on different physical machines, and because all sub domains are present inside a single tier, that shows that tiers are split up along technical boundaries, not functional ones. Usually data flows from one tier to another without skipping tiers. The N-tier architecture allows you to develop and deploy the tiers independently. The idea is that if something in the business logic changes, you only have to modify that single tier. In theory, each tier can also be scaled independently. However, in reality, things don't always pan out like that. Often a change in one tier requires a change in the other tiers. For example, a new field in a form will require changes in the UI, business logic and database. In the exercise files, I've added a sample N-tier application. You can run the application and you should see a dashboard. You can already see that there are two applications running. Let's click through to the presentation tier, and you should see a fictional travel agency website. We can list the tours, click on the learn more button and book a tour. This works just as we did in the monolith video. Now, if we go back to our dashboard and check out the logs, we'll see that there are two log lines for sending an email and calling an API of a travel agency. If we query the database, we can also see that our tour has been persisted. If we look at how the code is organized, we can already see that we have two applications, the business tier and the presentation tier. These are two of the three-tiers, the third one being the database. We are running everything on a single machine now, but we could deploy our tiers on different servers. Now, if we dive into the presentation tier, we can see that our tours page contains the necessary markup to display the tours, and in the code behind file, we can see that we're calling the business layer API to get the tours. This is a HTTP call over the network that the business tier receives in the tours controller. And in the tours controller, we can see that we call the tours repository to go to the database, retrieve the tours, and return it to the presentation tier. Our business tier is very basic, but in a real life application this tier would contain all the business rules and processes. The interior architecture has lost a bit of its popularity, but there are still many older systems that follow this pattern. That's why it's good to be able to recognize it and know how it works.

### Service-oriented
- [Instructor] Let's have a look at the service-oriented architecture. A service-oriented architecture is an architecture that consists of multiple services that each represent a business activity. Separate services may consist of other underlying services. Often, a service-oriented architecture will also include standardization of data contracts between services and an enterprise service bus. This requires a strong central governance of the architecture. This is what it could look like. There are multiple services that communicate with each other over the central enterprise service bus. The bus can handle multiple different messaging protocols. For example, when a product is requested, it always has the same structure regardless of who needs it. This is the standardized contract I mentioned earlier. The enterprise service bus will also contain business logic as to what should happen with the different messages. For example, duplicating events and routing it to the correct receivers. Service-oriented architecture gives us some flexibility in development and deployment because services are decoupled. This also makes them more easily scalable. In service-oriented architecture, business capabilities aren't duplicated across applications, but centralized in dedicated services. However, the centralized governance required for this architecture does mean we lose in team autonomy and agility. Many aspects of service-oriented architecture can be quite costly in terms of money, time, and effort, setting up an enterprise service bus or developing and enforcing standardized contracts, for example. Another disadvantage is that there isn't a clear view of what a true service-oriented architecture is or is not. I've created a simple example of what a service-oriented architecture could look like. You can find it in the corresponding exercise folder. If we start the application, you should see a dashboard just like in our previous videos. Immediately, we can see the different components like the tour service, the travel agent service, and the ESB, which is the enterprise service bus. Now, if we go to the website, we can create a booking. We'll see the different tours we can choose from, check out the details, and create a booking. Now, when we do that, our web application is requesting data from and pushing data to other services. Everything goes through the ESB. Now that our trip is booked, we can check out the logs, and if we use this filter we can see that we've sent an email and created a booking at a travel agency API. We can also query our database and see that our booking has been persisted. Let's jump through the code. When we want to see our tours, our tours page contains necessary markup to display the tours, and in the code behind, we see that we call the esbProxy to get the tours. If we go into that implementation, we see it's a HTTP call to our enterprise service bus. Now, let's check out our enterprise service bus. In this example, it's just a basic controller containing all the necessary hard-coded logic. In a real service-oriented architecture application, you would use a professional ESB product and configure it to route requests and messages to the right services. A true ESB can also map data structures, work with multiple protocols and much more. As you can see here, if we request the tours, we make a HTTP call to the tour service and return the results. The calling services don't need to know where the tour service is located or which protocols it accepts. In similar ways, every piece of communication goes through the enterprise service bus. When we make a booking, this is what happens. The UI sends a booking request to the ESB, which enters here, and it gets forwarded to the booking service. This stores the booking and sends another message back to the ESB, to the booking made endpoint. This message doesn't say what needs to be done. Rather, it represents the event that a booking was made, and the ESB then contains the business logic to notify both the email service and the travel agent service. There might still be a discussion on the exact definition of service-oriented architecture, and there are probably many different variations, but with this example, you now have an idea of the basic components and interactions in this architecture.

### Microservices
- [Instructor] It's time to dive into microservices. Microservices are a natural evolution of service-oriented architectures. An application is split up into multiple separate services that provide business functionality. Separate teams not only build the service, they're also responsible for running and maintaining it. For communication between services, a standard protocol like HTTP or a lightweight message broker is used. Unlike service-oriented architecture, the message broker doesn't contain any business logic. Because of the increased complexity of a microservices architecture, organizations will invest heavily in automation of testing, deployment, infrastructure configuration, and monitoring. It's important to zoom in on one of these points. The business activity of a microservice is more than just keeping track of data. It's also responsible for the business processes surrounding the activity. For example, an invoice service may be part of an e-commerce system. A simple implementation could make a call to the product service to get the names of the products on the invoice. But if the product service is down, the invoice service can't execute its business processes. This kind of a cascading effect so that the whole system goes down. However, if the invoice system has its own set of product data, it can continue working without the product service. This means that by focusing on business activities, you will probably need to duplicate some data throughout your system. Microservices have some great advantages. Services are independent of each other, making them more scalable. There's also no single team or service that acts as a central bottleneck, giving you greater agility. A high level of automation also reduces the chances of human errors and increases the reliability of your system. These advantages assume you've built your architecture correctly with all these aspects in mind, and that is one of the disadvantages. Building scalable, fail-safe microservices isn't easy and will require skilled engineers and an organizational and cultural change. It can be difficult to determine the boundaries of a microservice, and even if it's clear now, boundaries may change over time, requiring you to make complex changes to your system across multiple services. Microservices can also lead to complex communication patterns where the individual services are easy to understand, but the communication between the many components is not. In the Exercise Files, you'll find a basic example of a microservices architecture. To run the application, you can run it from Visual Studio. We can now navigate to our website and take a look at the different tours. If we click through, we can create a booking. Now, if we go to the database, we can verify that the booking has been persisted. And if we check our logs, we can check that we sent the email and sent an API call to a travel agent service. Back in Visual Studio, we can see our different microservices, each corresponding with our business functionalities. There's our website, our travel agent service, tour service, email service, and booking service. Each service also has a Docker file to automate deployments and execution. We can't go into the details of Docker here, but you can search in the LinkedIn Learning catalog for some great courses on Docker and containers. Notice also how the email's database has a tourist table. This is to ensure that if the tour service is unavailable, the mail service can still do its work, but it also means that we'll have to implement a system to duplicate some data and keep it up to date across your microservices. The core of microservices is that you have individual business services that communicate with each other through lightweight channels and that you automate as much as possible.

### Serverless
- [Instructor] Let's look at serverless architectures. Actually, a serverless architecture can take on two flavors. Backend-as-a-service is an architecture where you still have your own application in the traditional sense for your business logic, but you use third-party services for other concerns. These could be cloud services for authentication, logging and storage, for example. A function-as-a-service architecture consists of multiple pieces of code called functions that run in short-lived containers that are entirely managed by a cloud platform. These containers can't contain any state because they often live for just a few invocations. Just like the backend-as-a-service architecture, the functions integrate with many cloud provider services. For the remainder of this video, we'll be focusing on the function-as-a-service variant, as it is what is most commonly understood as serverless. A serverless architecture has several advantages over more traditional architectures. First, serverless applications scale very easily. If there is a peak in requests, the platform can automatically spin up new instances of your functions. Because many parts of your applications and its infrastructure are managed by the cloud platform, you have less infrastructure to manage as well. And because a new function is so easily written and deployed, it's very easy to experiment with new IDs. There are also disadvantages to serverless architectures. When you choose a specific vendor, you'll have to work with the constraints that they enforce. For example, a vendor might stop supporting a version of a framework you're still using. It also won't be easy to switch vendors. Developing a serverless application is also very different to what many developers are used to. One example of this is that your functions should be stateless. For example, if a client modifies something in memory, you can't be sure that another invocation or another client will run on the same instance. Serverless functions also suffer from a concept called cold starts. This is where the first invocation of a function takes slightly longer because the platform has to spin up a new container. Once it is running, however, subsequent invocations will perform better. And finally, while proponents of the serverless architecture may argue that it's cheaper, this really depends on your use case. Most cloud providers charge according to the resources you use, but it can be quite difficult to calculate the expected use upfront. To see an example of a serverless architecture, take a look at the serverless folder in the exercise files. This application consists of two Azure functions, a sender and a receiver. Luckily, we can run them entirely on our local machine. First, in the HTTP file in the sender project, let's first send a HTTP request to our sender. In the log of the receiver, we can see that we received the message. Now, what does this look like internally? Both functions are just a single file as you can see here. Here's the booking function, and in the receiver, we have our bookings processor. The sender is triggered by a HTTP request and put something on the queue. And on the receiving side, you can see that it is triggered by a queue trigger. Of course, this is a very simple application, and you could split a more complex application over more files, but the infrastructural side of the code is much simpler than in traditional applications.

### Distributed systems
- [Instructor] Let's take a step back and consider distributed systems. We've covered service oriented architectures, microservices, and serverless, these are examples of distributed systems. The user experiences the application as a single system, when in fact it's built from many different applications. A first important consequence of distributed systems is the risk of losing transactional integrity. This is the idea that we must ensure our data remains consistent after a user action. Here's an example, when a user submits a form in a monolith, we can update multiple database records in a single database transaction. When a table causes an error, the transaction is rolled back and nothing is modified. If there are no errors, all tables are updated, it's all or nothing. Now, let's take this example to a microservices architecture without transactional integrity. If two services update our databases, but a third one fails, our data can lose its consistency. We can't use a single database transaction because we're using different running processes and even different databases. There are different ways to solve this. For example, the saga pattern ensures that the stored data is reset to its previous state with what is called a compensating action. But what if a service is down? Direct HTTP calls won't reach it, causing a rippling effect throughout our system. An interesting pattern is a transactional outbox pattern. In this pattern, a single service modifies its data, but also stores a message in the same database transaction. Then, there's a separate piece of logic that regularly processes any unsent messages. This way, the sender can be sure the receiver will eventually receive the message. Using a message broker instead of direct HTTP calls can also help out by making our communication asynchronous. Once the service comes back up, it can process all messages in the queue, and sending surfaces can be sure their messages will eventually be processed. Another consequence of distributed systems is that your data will often be duplicated. This can be quite jarring for developers used to a certain way of working. If you have an invoicing service, for example, and it needs a customer's address, you could query the customer service every time, but again, if the customer service is unavailable, this service can't perform its work. It's better to duplicate the customer address inside the invoicing service so it can perform its work independently. If the address changes, just send a message from one service to the other and update accordingly. With all this messaging going on, you'll need to clearly define the structure of the messages or what's called the contract. If a contract changes, receiving services need to know about this change, so the code can be updated as well, which also means, you need to avoid breaking changes or at least introduce them in a phased manner so every team has time to update their code. In this video, I've only briefly covered transactional integrity, duplication of data, and messaging. There are many more challenges that come with distributed systems. But there's no need to panic, just be aware of them and read up on these architectures before you start implementing them, your distributed systems will only benefit.

Saga Pattern
Transactional outbox pattern 

### Peer-to-peer
- [Narrator] Now we're going to take a look at the peer-to-peer architecture. The peer-to-peer application is a special case in our catalog of software architecture patterns. Peer-to-peer applications are a network of applications that communicate with each other without a central server in between them. The individual applications don't have to be online all the time. They can connect and disconnect as they please. This means they need a way to discover each other because they might not have fixed URLs or IP addresses. As you can see in this diagram, the communication goes from one machine to another directly. In a closed network, the machines will be able to find each other easily. This isn't the case in a large network like the internet, which is why sometimes a central server is added. Each machine can notify the central server that they are online, after which the central server can notify the others. Then, the direct peer-to-peer communication can continue without the central server. Peer-to-peer applications serve a specific purpose. They're ideal for applications that want to share their resources, like processing power, data, memory, or storage. Because there's no central server, they can be cost-effective, especially if your organization doesn't have to run all the individual clients. Scaling the system is also easy. All you need to do is add more applications or machines to the network. There's no extra configuration necessary, and often people already have a machine available, so there's no need for expensive server purchases. But, peer-to-peer applications have their drawbacks. Because the system is so decentralized, there are potential security issues. For example, in a data sharing network, viruses can transfer more easily. Or in an application that distributes calculations, some corrupt nodes in the network might spread incorrect results. And let's not forget that peer-to-peer applications only lend themselves to specific scenarios, therefore sharing resources, which is why most of us will probably not encounter such an architecture in our professional work.

Q: You are updating the UI tier of an N-tier system. What additional updates, if any, are probably required?
A: You may have to update the business logic and data tiers.

Q: Why would you consider a monolithic architecture over other architectures?
A: It is easy to understand, implement, and test.

Q: You and your development team are tasked to deploy a peer-to-peer (P2P) system for a new multiplayer game. Why should you consider adding a server just for the P2P system?
A: to assist with notifying the network of new machines that come online

Q: When should you consider using a function-as-a-service serverless architecture?
A: when you have a number of functions you need to run that can be hosted on a third-party platform

Q: How does a microservice architecture fundamentally differ from a service-oriented one, and what advantage does this provide over service-oriented architectures?
A: Services talk directly to each other, which increases agility.

Q: Your team is considering a service-oriented architecture. Why is choosing this architecture over other architectures advantageous?
A: It is more easily scalable than some other architectures.

## Application Patterns

### Layered
- [Instructor] The layered application pattern is a classic pattern that you'll encounter often in various forms. A layered application is an application that has several layers. Each layer has distinct responsibilities. The idea behind the layered application is that calls in the code flow downwards. A layer can call the layer below it, but not above it. There are five layers that occur often. The presentation layer contains the user interface. The application layer is the layer that receives calls from the UI and translates them into calls that the business layer can understand. The business layer contains all the business logic, and the persistence layer is where we put the code that knows how to interact with the database. Finally, the database is where we store the actual data. If necessary, you can add more layers, like a caching layer, for example, or in some scenarios, two layers can be merged into one. The layered architecture is well-known among many developers, and it's also an easy way of organizing the code in your application, but there can be some significant drawbacks to layered applications. They tend to lead to highly coupled code that becomes hard to maintain. The layered pattern often requires us to write a lot of code to pass data from one layer to another, where no value is added in the intermediate layers. Because the application is split up across technical boundaries, it's difficult to take a specific business functionality and split it off into a new application. In the exercise files, I've created a simple example of a layered architecture application. You can start it from Visual Studio or the command line, and you'll see a dashboard. Once everything is running, we can navigate to our website, and you should be able to see a list of tours and create a booking. So here we go with the list of tours. If we click on learn more and book now, we can create a new booking. Now, this application behave just like the application that we saw in previous videos. Back in Visual Studio, you can see how the application is structured in the solution explorer. I've put everything in solution folders because Visual Studio would list the layers alphabetically, not from top to bottom. So at the top, we have the presentation layer, which contains our UI markup. For example, here we have the booking page with its HTML, and in the code behind, we can see that if we want to create a booking, we create a new booking object and call the save method on the bookings controller. The bookings controller is an object that lives in the application layer. The bookings controller will map the booking from the application layer to a booking from the business layer and then call the booking service, which lives in the domain layer or the business layer. As we can see, the booking service contains the business logic to call the bookings repository to save our booking to the database, and also retrieve the tour and send a confirmation mail and notify the travel agency. And the bookings repository and the code for calling the external APIs lives in the infrastructure layer. For example, here we can see the bookings repository. So as we can see, all calls go downwards, so that's the structure and flow of data in a layered application. I've shown you a monolithic system, but it would be perfectly fine to have a layered application be part of a larger system, like a service-oriented or microservices architecture.

