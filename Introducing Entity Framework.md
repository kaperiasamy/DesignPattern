# Introducing Entity Framework

## Getting started with Entity Framework Core
Hi, friends. I'm Cam Soper, a content developer working on .NET here at Microsoft. In this video, we're going to get started with Entity Framework Core, which is a toolset that makes it easy to store your .NET objects in a variety of databases without writing much, if any, database code. EF Core allows you to use a variety of databases such as SQL Server, SQLite, Azure, Cosmos DB and Postgres, just to name a few. Here's an entity diagram describing the entities we're going to persist to our database. These entities support a pizza delivery website, ContosoPizza. As you can see, a customer can place one or more orders. Each order contains one or more order details, and each order detail contains a product and quantity. Let's dive in. I've got an empty .NET 6 console project. I'm going to manage my NuGet packages for the project and search for Microsoft.EntityFrameworkCore. I'll grab the Microsoft.EntityFrameworkCore.SQLServer package and install it to my project. Now that that's installed, I'm also going to install Microsoft.EntityFrameworkCore.Design and Microsoft.EntityFrameworkCore.Tools To get started with Entity Framework Core, we need to build classes describing our entity model. By convention, these are usually stored in a folder called models. I'm going to create my first entity, probably the simplest one, product. We've created an empty class. And for expediency, I'm going to paste in some code. Looking at the product class, the first thing that I want to call out is this first property ID. In EF Core ID is a special property name that indicates that this property is to be the primary key in the generated table. It doesn't have to be named ID, it can be the table name followed by ID or it can be anything we want, in which case we decorate the property with the key attribute to indicate that it's a primary key. The other two properties on on this class are name and price. Price is defined as a decimal with two points of precision. You may be wondering why I've initialized name as null with an exclamation point. That's because in .NET 6 all projects enable nullable reference types by default. Without this initialization, the compiler warns us that it can't see where the non-nullable string name is initialized. Since EF Core manages entity initialization for us, I suppress this warning by explicitly initializing the property as null with the null for giving an operator. This lets the compiler know that we know what we're doing so it doesn't need to warn us about this assignment. If you need to use a nullable reference type in your model, but you don't want null stored in the database, you can use the required attribute. That's not the case here. So I'll revert this to the way I had it originally. The next class I'm going to add will be the customer entity. Here we're using nullable and non-nullable reference types to define which database fields should allow null and which ones shouldn't. Since first name and last name are non-nullable strings, EF `Core knows that when it creates a table, those two columns should allow null. The address and phone properties, on the other hand, are nullable strings, so the database will allow nulls in those columns. We don't need to initialize these because they're declared as nullable. Finally, the last property on the class called orders is a collection of order objects. We haven't created the order class yet. We're going to do that in just a second. This is called a navigation property, and it indicates that a customer may have zero or more orders. This creates a one to many relationship in the database that gets generated. Creating the empty order class, I'll again paste in some code to define my properties. This should look pretty familiar. We have an ID property along with order place and order fulfilled properties. We also have a customer property. That's another type of navigation property specifying one customer entity for order. We've included a customer ID property to represent the foreign key relationship to the customer table that will be generated. If we omit that customer ID property, that's okay. EF Core will created anyway as what we call a shadow property. Finally, we have another navigation property for a collection of order details. The final class we're going to create. Let's look at order detail. This entity will generate an intersection table to facilitate the many to many relationship. It has navigation properties for both order and product. As with the order class, the order ID and product ID represent foreign key relationships and aren't strictly required. Now we're going to create a database context class. By convention, this will go in a directory called data. I'm going to name my class ContosoPizzaContext. ContosoPizzaContext derived some DB context. Think of DB context as representing a session within the database. On the DB context derived class, we have four properties of type DB set. Each DB set maps to a table that will be created in the database. Finally, we've overridden the on configuring method to include some configuration information. Since we're using the SQL Server package, we have a U-SQL Server extension method available to us that configures the SQL Server database provider. You can find the connection string in the notes for part one. Set the connection string to the correct connections string for your environment. Hardcoding a connection string like this is a bad practice and I'm just doing it for demonstration purposes. Always use a secure storage method for real world connection strings. Now that we've created our entity model, we're going to create something called a migration. The EF Core Migrations feature is a tool that makes it easy to create and evolve our database. Since I'm using Visual Studio, I'm going to use the package manager console to run the add migration command line. I'll name my migration initial create. If you're not using Visual Studio, you can use, you can do these same tasks using the .NET CLI. First, install the .NET EF tool as a global tool. Then use the .NET EF migrations add command to create the initial create migration. Going back to Visual Studio, let's take a look at the generated migration. We should look it over to make sure it's accurate and it creates the table the way we want it to be created. Looking at the products table as an example, we can see where it's creating our identity column, which is our primary key. Our name, which is not nullable, and price, which is a decimal with two points of precision. I'm satisfied that the migration is correct. So I'm going to run the migration with Visual Studio's update database command line. The equivalent .NET CLI command is .NET EF database update. Now let's take a look at the database that was created. The first table we're going to look at is this one that we didn't actually create, EF migration history. This table is created by EF Core to track which migrations have been run against the database. Let's look at the products table. It looks like the products table was generated exactly as we intended. Let's also look at the customer table. The customer table was generated pretty much as expected, except I just realized that I forgot to include an email property. Let's go back to the customer entity and add a property for email. Email will be a nullable string. Now that we've modified the customer entity, we'll create another migration. I'll name this one add email. This migration will handle adding the new column. I'll run the migration and update the database again to make sure our database is up to date. As expected, the email column has been added to the table. Now that we've built our database context and entity model, let's go to program.cs and do something with them. To get started, I'm going to add a few products to my products table. The first thing I'm going to do is I'm going to use a using declaration to create a new instance of ContosoPizza context. This using declaration ensures that the ContosoPizza context object is disposed of properly when we're done using it. The first product I'm going to add to my table will be a veggie special pizza. I'll create the veggie special object and then call the add method on the product's DB set property. The next product I'm going to add will be a deluxe meat pizza. This time I called the add method from the context object. EF Core can infer that this entity is a product based on its type and I don't need to use the product DB set. Finally, I'll call the save changes method on the context to persist the changes to the database. Let's run it and see what happens. In Visual Studio you can use the start debugging button. If you're using the CLI, run the app with .NET run. The app is done running. Let's go look at the database. As expected, two products have been added to our products table, the veggie special pizza and the deluxe meat pizza. Now that there are some entities in the database, let's try reading them. Using that same ContosoPizza context reference, I'm going to query the products table using a fluent API. Fluent API use extension methods to chain methods together along with Lambda expressions to specify the query. In this case, we're looking for any product where the price is greater than ten and we're going to order by name. Then we're just going to write it all out to the console. If you don't like the fluent API syntax, you can use the link syntax. Link syntax is very similar to SQL code. Let's replace the fluent API syntax with the link syntax. Both of these methods are equivalent and result in the same queries to the database. Let's run the app. As expected, our one product whose price is greater than ten shows up in the results. Now that we've read entities from the database, let's try updating an entity. To update an entity, first, I'll get a reference to it. I'll query the table looking for any product whose name is veggie Special pizza and take the first or default result. If there's no record that matches that name, we'll get the default, which is null. Here we check to see if the veggie special object is a product object and not null. If it's a product object, we'll set the price to 1099. Finally, we'll call save changes on the context to persist the changes to the database. Let's run it. Since we changed the price to greater than ten, veggie special pizza shows up in the results that now. The final thing I'm going to show you is how to delete an entity from the database. To delete you simply pass a reference to the entity to the remove function on the database context. Let's run it one last time. As expected, veggie special pizza is now deleted. That's how easy it is to use Entity Framework Core to persist .NET objects in a database. In this video, we used EF Core migrations to create a new database from our code. In the next video, I'm going to show you how to go the other way, scaffolding code from an existing database.

