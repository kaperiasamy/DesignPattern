# Introducing Entity Framework

## Getting started with Entity Framework Core
Hi, friends. I'm Cam Soper, a content developer working on .NET here at Microsoft. In this video, we're going to get started with Entity Framework Core, which is a toolset that makes it easy to store your .NET objects in a variety of databases without writing much, if any, database code. EF Core allows you to use a variety of databases such as SQL Server, SQLite, Azure, Cosmos DB and Postgres, just to name a few. Here's an entity diagram describing the entities we're going to persist to our database. These entities support a pizza delivery website, ContosoPizza. As you can see, a customer can place one or more orders. Each order contains one or more order details, and each order detail contains a product and quantity. Let's dive in. I've got an empty .NET 6 console project. I'm going to manage my NuGet packages for the project and search for Microsoft.EntityFrameworkCore. I'll grab the Microsoft.EntityFrameworkCore.SQLServer package and install it to my project. Now that that's installed, I'm also going to install Microsoft.EntityFrameworkCore.Design and Microsoft.EntityFrameworkCore.Tools To get started with Entity Framework Core, we need to build classes describing our entity model. By convention, these are usually stored in a folder called models. I'm going to create my first entity, probably the simplest one, product. We've created an empty class. And for expediency, I'm going to paste in some code. Looking at the product class, the first thing that I want to call out is this first property ID. In EF Core ID is a special property name that indicates that this property is to be the primary key in the generated table. It doesn't have to be named ID, it can be the table name followed by ID or it can be anything we want, in which case we decorate the property with the key attribute to indicate that it's a primary key. The other two properties on on this class are name and price. Price is defined as a decimal with two points of precision. You may be wondering why I've initialized name as null with an exclamation point. That's because in .NET 6 all projects enable nullable reference types by default. Without this initialization, the compiler warns us that it can't see where the non-nullable string name is initialized. Since EF Core manages entity initialization for us, I suppress this warning by explicitly initializing the property as null with the null for giving an operator. This lets the compiler know that we know what we're doing so it doesn't need to warn us about this assignment. If you need to use a nullable reference type in your model, but you don't want null stored in the database, you can use the required attribute. That's not the case here. So I'll revert this to the way I had it originally. The next class I'm going to add will be the customer entity. Here we're using nullable and non-nullable reference types to define which database fields should allow null and which ones shouldn't. Since first name and last name are non-nullable strings, EF `Core knows that when it creates a table, those two columns should allow null. The address and phone properties, on the other hand, are nullable strings, so the database will allow nulls in those columns. We don't need to initialize these because they're declared as nullable. Finally, the last property on the class called orders is a collection of order objects. We haven't created the order class yet. We're going to do that in just a second. This is called a navigation property, and it indicates that a customer may have zero or more orders. This creates a one to many relationship in the database that gets generated. Creating the empty order class, I'll again paste in some code to define my properties. This should look pretty familiar. We have an ID property along with order place and order fulfilled properties. We also have a customer property. That's another type of navigation property specifying one customer entity for order. We've included a customer ID property to represent the foreign key relationship to the customer table that will be generated. If we omit that customer ID property, that's okay. EF Core will created anyway as what we call a shadow property. Finally, we have another navigation property for a collection of order details. The final class we're going to create. Let's look at order detail. This entity will generate an intersection table to facilitate the many to many relationship. It has navigation properties for both order and product. As with the order class, the order ID and product ID represent foreign key relationships and aren't strictly required. Now we're going to create a database context class. By convention, this will go in a directory called data. I'm going to name my class ContosoPizzaContext. ContosoPizzaContext derived some DB context. Think of DB context as representing a session within the database. On the DB context derived class, we have four properties of type DB set. Each DB set maps to a table that will be created in the database. Finally, we've overridden the on configuring method to include some configuration information. Since we're using the SQL Server package, we have a U-SQL Server extension method available to us that configures the SQL Server database provider. You can find the connection string in the notes for part one. Set the connection string to the correct connections string for your environment. Hardcoding a connection string like this is a bad practice and I'm just doing it for demonstration purposes. Always use a secure storage method for real world connection strings. Now that we've created our entity model, we're going to create something called a migration. The EF Core Migrations feature is a tool that makes it easy to create and evolve our database. Since I'm using Visual Studio, I'm going to use the package manager console to run the add migration command line. I'll name my migration initial create. If you're not using Visual Studio, you can use, you can do these same tasks using the .NET CLI. First, install the .NET EF tool as a global tool. Then use the .NET EF migrations add command to create the initial create migration. Going back to Visual Studio, let's take a look at the generated migration. We should look it over to make sure it's accurate and it creates the table the way we want it to be created. Looking at the products table as an example, we can see where it's creating our identity column, which is our primary key. Our name, which is not nullable, and price, which is a decimal with two points of precision. I'm satisfied that the migration is correct. So I'm going to run the migration with Visual Studio's update database command line. The equivalent .NET CLI command is .NET EF database update. Now let's take a look at the database that was created. The first table we're going to look at is this one that we didn't actually create, EF migration history. This table is created by EF Core to track which migrations have been run against the database. Let's look at the products table. It looks like the products table was generated exactly as we intended. Let's also look at the customer table. The customer table was generated pretty much as expected, except I just realized that I forgot to include an email property. Let's go back to the customer entity and add a property for email. Email will be a nullable string. Now that we've modified the customer entity, we'll create another migration. I'll name this one add email. This migration will handle adding the new column. I'll run the migration and update the database again to make sure our database is up to date. As expected, the email column has been added to the table. Now that we've built our database context and entity model, let's go to program.cs and do something with them. To get started, I'm going to add a few products to my products table. The first thing I'm going to do is I'm going to use a using declaration to create a new instance of ContosoPizza context. This using declaration ensures that the ContosoPizza context object is disposed of properly when we're done using it. The first product I'm going to add to my table will be a veggie special pizza. I'll create the veggie special object and then call the add method on the product's DB set property. The next product I'm going to add will be a deluxe meat pizza. This time I called the add method from the context object. EF Core can infer that this entity is a product based on its type and I don't need to use the product DB set. Finally, I'll call the save changes method on the context to persist the changes to the database. Let's run it and see what happens. In Visual Studio you can use the start debugging button. If you're using the CLI, run the app with .NET run. The app is done running. Let's go look at the database. As expected, two products have been added to our products table, the veggie special pizza and the deluxe meat pizza. Now that there are some entities in the database, let's try reading them. Using that same ContosoPizza context reference, I'm going to query the products table using a fluent API. Fluent API use extension methods to chain methods together along with Lambda expressions to specify the query. In this case, we're looking for any product where the price is greater than ten and we're going to order by name. Then we're just going to write it all out to the console. If you don't like the fluent API syntax, you can use the link syntax. Link syntax is very similar to SQL code. Let's replace the fluent API syntax with the link syntax. Both of these methods are equivalent and result in the same queries to the database. Let's run the app. As expected, our one product whose price is greater than ten shows up in the results. Now that we've read entities from the database, let's try updating an entity. To update an entity, first, I'll get a reference to it. I'll query the table looking for any product whose name is veggie Special pizza and take the first or default result. If there's no record that matches that name, we'll get the default, which is null. Here we check to see if the veggie special object is a product object and not null. If it's a product object, we'll set the price to 1099. Finally, we'll call save changes on the context to persist the changes to the database. Let's run it. Since we changed the price to greater than ten, veggie special pizza shows up in the results that now. The final thing I'm going to show you is how to delete an entity from the database. To delete you simply pass a reference to the entity to the remove function on the database context. Let's run it one last time. As expected, veggie special pizza is now deleted. That's how easy it is to use Entity Framework Core to persist .NET objects in a database. In this video, we used EF Core migrations to create a new database from our code. In the next video, I'm going to show you how to go the other way, scaffolding code from an existing database.

## Working with an existing database
Hi friends. Welcome back to Entity Framework Core for Beginners. In our previous video I showed you how easy it is to use Entity Framework Core migrations to create and work with a new database. First, we defined our entity model in code. Then we used migrations to change the database as we made changes to the model. When we use that approach, we're treating the code as the authoritative source of truth regarding the shape of our entities. In this video, I'm going to show you how to use Entity Framework Core to work with an existing database by reverse engineering it. This approach treats the database as the source of truth. Looking at Visual Studio, I have a brand new console app that doesn't have any code added to it at all. I've already added the Microsoft.EntityFrameworkCore.SQLServer, .Design, and .Tools NuGet packages. I have an existing database. Let's assume this database was created and maintained by my organization's database administrator. This database is already populated. To reverse engineer the database and create my entity model code, I'll start by using the scaffold dbcontext command-let. I'm going to pass in the connection string, which can be found in the notes. Then I'll pass in the name of the provider so it knows what type of database to execute the connection string against. And then I'll optionally specify output directories for the DB context and models classes. If you're using the .NET CLI, the command is dotnet ef dbcontext scaffold. The parameters are pretty similar. Check the notes for more. Now that the scaffold is run, we have a complete working entity model. Looking at the product entity, it should look pretty similar to the one we created in the last video. One difference you'll note, however, is that there are no data annotations describing the behavior of these properties like the one we used previously on price. That's because these behaviors are contained in the on model creating method of the database context. This is another way EF Core lets you control the relationship between your entities and the database. If we'd like to generate an entity model that looks more like the one we created in the previous video, we can do that too. I'll start by deleting this entity model. And now I'll run the scaffold dbcontext command-let again. This time I'll add the data annotation flag. Now the product entity has data attributes that describe the behavior of the properties. The on model creating method in the database context class is also much more sparse. You might be wondering what do we do when the database schema changes? Well, there are two strategies. The first strategy is a manual approach. This approach requires you to manually edit your entity model to keep it in sync with the database schema. The generated DB context and model classes can be thought of as a starting point for ongoing development. Similar to Scaffolded Razor Pages in an ASP.NET Core web app. The other strategy is re-scaffolding the entity model whenever the database schema changes. Using this approach, it's important to use partial classes or extension methods to keep business logic separate from the scaffolded entities. This ensures that business logic doesn't get overwritten if you re-scaffold the entities. Let's take a look. I'm going to delete my entity model and re-scaffold. This time I'm going to generate my models in a subdirectory of the models directory. I'll also specify the namespaces for the generated DB context and models. Now I can create partial classes in the models directory to contain my business logic. This way I can regenerate the entity models without disturbing my business logic. Let's paste some code under program.cs so we can see the partial class in action. Now that we've seen how Entity Framework Core can work with an existing database, in the next video, I'm going to show you how to use Entity FrameWork Core with ASP.NET Core to streamline your web development.

## ASP.NET Core web apps with EF Core
Hi friends. Welcome back to Entity Framework Core for Beginners. In this video, I'm going to show you how you can use Entity Framework Core along with ASP.NET Core to streamline your web development. I've already created an empty ASP.NET Core Razor Pages web app. I used the command I showed you in the last video to scaffold a DB context and models against that same database. Now we're going to scaffold some Razer pages that use ContosoPizza context to interact with the database. ContosoPizza context contains the connection string that was used for scaffolding in the on configuring method. We're going to get our connection information from configuration, so let's delete that method. Now I'm going to visit program.cs. I'll paste in some code and then I'll add the using directives to resolve the references. The add dbcontext extension method registers ContosoPizza context with ASP.NET cores dependency injection container. We passed the method a lambda expression that configures EF Core to use the SQL Server database provider using a connection string retrieved from configuration. In previous videos, I've mentioned that it's a bad practice to store your connection strings with your code. The .NET Secrets Manager gives us a mechanism to separate our secrets from our code. Let's use the .NET Secrets Manager to store that connection string. I'm right clicking on the project and selecting Manage User Secrets. Visual Studio opens a file called secrets.json for editing and I'll paste in my connection string. This file is stored in your user profile on your development machine. The secrets aren't encrypted. It's just a location to store them away from your code. At runtime, ASP.NET Core will look for the configuration in app settings.json and other locations. Secrets.json is one of the locations it checks. If you're using the .NET CLI, you must first initialize the secret store with .NET user secrets in it. Then you can add your secrets with .NET user secrets set. Now we're going to generate razor pages to support creating, reading, updating and deleting products. These operations are collectively referred to as CRUD. The first thing I'm going to do is add the Microsoft.VisualStudio .Web.CodeGeneration.Design package to the project. This installs some dependencies for the scaffolding tool. Now I'll create a products folder inside the pages folder. After that, I'll right click on the folder, select add and then a new scaffolded item. In the dialog that follows, select Razor pages using Entity Framework CRUD. Select product as the model class and ContosoPizza context as the data context class. Click add. If you're using the .NET CLI, first install the .NET ASP.NET Code generator tool as a global tool. Then use the .NET ASP.NET Code Generator command to scaffold the pages. I've put the full command in the notes. The scaffolding creates five pages. Create, delete, details, edit and index. I'm going to run the application. I'll edit my URL to navigate directly to the product's index page. This view lists all the products in the table. I'm going to leave the app running, but I'll switch back to my IDE. Let's look at the code for index.cshtml.cs Notice that we're injecting ContosoPizza context into the constructor. ASP.NET Cores dependency injection container takes care of this for us. All we have to do is ensure the constructor has the right signature. The products collection is accessed by a property on the page model class. The OnGet method sets that property equal to the contents of the products DB set. The Razor view enumerates over that list of products and for each product lists the name and price. Let's use the create page to create a new product. There's a new product. Let's look at what happened in the code. We'll start with the page model. The OnGet method in the page model returns the empty form, which is a Razor view. The Razor view has elements to support name and price. It uses label input and span elements to build the form that we saw earlier. This includes validation that enforces the constraints in our model classes. When we post the form, the model binder binds the elements on the form to our product property, which in turn is added to the products DB set. Finally, we call save changes async to save the changes to the database. Let's edit a record. When we visit this page, the name and price elements are pre-populated with existing data. Looking at the page model for edit, the OnGet method queries the database for products that match the ID that was passed in on the URL's query string. We retrieve that product and present it for the user to edit. When the user posts the form, the model binder builds a product object from the elements on the page, attaches it to the existing entity, marks it as modified and saves the changes. The final view we're going to look at is delete. The delete view is similar to the edit view. The first thing OnGet does is look up the product by ID and display it for the user. When the user clicks the submit button, we find that same product by its ID. Then we call remove on the products DB set, passing in the entity to delete. In this video, we saw how easy it is to use ASP.NET Core along with Entity Framework Core to streamline your web development. In the next video, we're going to look at using different database providers with Entity Framework Core.

## Database providers
Hello again, friends. Welcome back to Entity Framework Core for Beginners. In previous videos we've looked at using Entity Framework Core exclusively with SQL Server. In this video, we're going to look at using Entity Framework Core with other database providers. The database provider is a layer in the EF Core architecture that's responsible for the communication between Entity FrameWork Core and the database. It's a pluggable architecture, which means EF Core can support all kinds of databases. The first database provider we're going to look at is SQLite. SQLite is an open source cross-platform embedded database technology. In SQLite, the entire database is stored as a single file. So it's a great choice when you don't want to take a dependency on a server based database platform. I'm starting with a console application preconfigured with my NuGet packages. I've already written context and model classes. The code in program.cs adds some records to the products table. Using a different database provider with EF Core is often as simple as using a different NuGet package. To use the SQLite provider, I'm going to install the Microsoft.EntityFrameworkCore.SQLite package. I'll uninstall the SQL Server package too. Then I'll go to the OnConfiguring method in ContosoPizza context and configure the context with the useSQLite extension method. The connection string points to the file to be created. Now I'll create my initial create migration. After that, I'll use the update database command-let to run the migrations. The ContosoPizza DB file was created. Before we run, since I'm using Visual Studio, there's one other thing I need to check. By default, Visual Studio wants to start the app in a different directory than the build directory. If it does that, my app won't find the database. Let's add a start working directory element to the csproj so that doesn't happen. Now let's run the app. It's done running. Let's see if we got any data in our file. In Visual Studio, I'll right-click and get the path of the database file, which I'm going to use to open in an open source tool called DB Browser. As you can see, the product data looks as we expected. Now let's do that same exercise again. But this time let's use Postgres. The database provider for Postgres is provided by the Postgres developer community. I'll add the Npgsql.EntityFrameworkCore .PostgreSQL package to the project and delete the SQLite package. Now I'll replace the call to the .useSQLite method with a call to use Npgsql. Let me paste in my connection string. Now I'll generate and run new migrations. Let's run the app. The app is done running. I'll switch over to the pgAadmin tool and query the database. As you can see, the product table has data. The final database provider I'm going to show you is for Azure Cosmos DB. Cosmos DB is a fully managed no SQL database for modern app development. This means that instead of working like a relational database management system, it works with JSON documents. I've already created a free Cosmos DB account configured to use the Core API. I haven't added any database containers yet. It's just an empty Cosmos account. I'll go to the keys tab to get my connection string then I'll go back to Visual Studio. I'll add the Microsoft.EdentityFrameworkCore. Cosmos package to the project and remove the Postgres package. This time I'll call the UseCosmos method. In addition to the connection string, I must also specify a database name. Since Cosmos DB is a no SQL database and there aren't any database schemas to update, let's delete the migrations folder. Since there are no migrations to create the initial database, let's call context.database.insurecreated in program.cs to make sure the database gets created. Ensure created can cause performance issues so avoid using it in production. One other difference we need to account for with Cosmos DB is the primary keys. The other databases we used support auto generating a primary identifier. Since Cosmos DB doesn't do that, we need to handle it ourselves. I'll change the ID in the product class to a string. I'll initialize it as a globally unique identifier. Since this primary key is a foreign key on order details, I'll change product ID in that class to be a string as well. And I'll assign it to null along with the null-forgiving operator. Let's run the app. Now that that's done, let's go over to the Azure portal where we can see the data we just added. In this video, we looked at how EF Core uses database providers to support a plethora of different database technologies. We looked at just three of the possible database providers you can use. Visit the Entity Framework Core documentation to see the full list of supported database providers. In the next video, I'm going to show you some tips to optimize performance in your EF Core applications.

## Performance tips
Hello again, friends. Welcome back to Entity Framework Core for Beginners. In this video, I'm going to show you some tips to get the most performance out of your EF Core applications. The first topic we're going to cover is change tracking. When EF Core queries a database, it stores a snapshot of the results set in memory. Any modifications you make to your entities are actually made against that snapshot and then later written to the database. In read only scenarios where there's no chance you'll actually want to write data back to the database, we can skip the snapshot and conserve system resources. Let's look at how to disable change tracking for a query. I've got my ContosoPizza web app open and I've set up my user secrets already. I'm going to disable change tracking on my customer index page since that page is read only. To disable change tracking on any results set, all we have to do is add the as no tracking method to the query. Now when we view the customer index view, EF Core will skip the snapshot. In our previous videos, we've looked at using navigation properties to load related entities. Entity Framework Core allows you to specify when those related entities are read from the database. We're going to look at two patterns for loading these entities; eager loading and lazy loading. We'll look at eager loading first. Here's that same customer index page. We're already using eager loading by way of the include method. The include method signals the EF Core that the related orders should be loaded on the same database query as the customers. Sometimes, however, it might benefit our app's performance to wait to load the orders until they're actually needed. This is called lazy loading. To enable lazy loading, first, I'm going to install the Microsoft.EntityFramework Core.Proxies package. I'm going to get rid of the include method. as no tracking doesn't work with lazy loading, so I'll get rid of that too. When I add the database context to the dependency injection container, I'm going to add use lazy loading proxies to the options. Finally, I'll go make sure the navigation properties are marked virtual so that Entity Framework Core can override them with proxies that it generates. Now, I've enabled lazy loading and the orders won't be requested from the database until they're actually needed by our code. When eager loading want many data sets, EF Core defaults to using left joins to get the entire data set from the database in one query. This can lead to very large data sets when the data from the left side of the join is repeated for each record returned on the right side. This is known as a cartesian explosion and it can be mitigated by using a feature called split queries. Split queries use multiple queries to get the same data set. I'm already running the app. The customer details page needs to use a lot of navigation properties. The debugger output shows the query that sent to SQL Server. You can see that it's using one big query. To use a split query, all I need to do is add the as split query method. Now I'll hot reload the page. This time, instead of a single SQL query, there are three. Sometimes when working with Entity Framework Core, you need to use your own SQL rather than the SQL that it generates for you. EF Core makes this easy, using the from SQL raw and from SQL interpolated methods. Let's look at the product detail page. That page is currently loading customer data using a where method. I'm going to use from SQL interpolated to specify my own SQL query to retrieve some customer information from the database. I'll use an interpolated string containing raw SQL and pass in the customer ID. Let's run it. After it launches, I'll drill down on a customer order to view a product. Entity Framework Core takes care of converting this interpolated string to a parameterised SQL statement which protects from SQL injection attacks. We've previously discussed how Entity Framework Core uses in-memory snapshots to track changes to our entities. If we happen to have an entity cache in the snapshot, we can save ourselves a trip to the database by looking it up with the find or find async methods. In my product's details page, I'm using first or default async to look up a product from the database by its primary key. Since I'm looking up an entity by primary key, I can instead use find async. This checks the snapshot first before calling the database. Whenever we use a database context, there's a certain amount of overhead that goes into creating and destroying the object. We can bypass that overhead by using database context pooling to reuse our database context objects over and over again. To use database context pooling, All we have to do is replace, add db context with add db context pool. Now our database context will be reused over and over again. This concludes Entity Framework for Beginners. Be sure to check out aka.ms/ef-core-101 for more great EF Core resources. Thanks for watching.

## How to code along with these videos
Hi, friends. I'm Cam Soper, a content developer working with .NET here at Microsoft. I wanted to take a few minutes to show you my recommendations on how to get the most from this video series. Before you get started, you should obtain the code, sample data and notes for the series. They're located on GitHub at the locations shown here. In the videos, I primarily use Visual Studio. This is a great option if you're a Windows user. If you're using Visual Studio, make sure you have the ASP.NET and web development workload installed. If you're developing on Windows, you'll also need a SQL Server Express local DB instance. A dackpack file is located in the dev container folder in the data subfolder. Use a tool like Azure Data Studio or SQL Server Management Studio to install the database and name it ContosoPizza. To follow along in Visual Studio, open the project file for the part you're viewing directly in Visual Studio. If you're using a non-Windows environment or you just prefer a different IDE, you can use the .NET CLI and your IDE of choice. I recommend Visual Studio Code. Open the entire repository folder. I used the CodeTour extension in Visual Studio Code to make tours that walk you through the code interactively. If you have the CodeTour extension installed, you can launch the CodeTour for each video part by right-clicking and starting the tour you want in the CodeTour pane in the Explorer. My favorite way to experience these videos is with a dev container. If you have a container environment configured, you can load the repository folder using Visual Studio Codes Remote Development Containers Extension. Visual Studio Code will build a container environment preconfigured with specific versions of the .NET SDK, SQL Server, Postgres and other tools, as well as the preexisting SQL Server database. You don't even need to install any extensions. There's nothing for you to do except launch the CodeTour. Finally, if your organization has access to GitHub code spaces, you can launch the dev container in the cloud without any local tools. Just navigate to the code repository, click the code button and create a new code space using the main branch. Thank you for watching these videos. I hope you find them informative and I hope you have as much fun watching them as I did making them.

